# Random Generation and Comparison of Simulink models

## Code

Development branch is `random-generation` where you can find latest code. Stable code can be found in `master`.

## Structure

 - All code is located under `slsf` directory. From now on, consider `slsf` as the root directory.
 - After running the program, results can be found in `reports` directory.

## How to run

 - Add `slsf` directory in your Matlab path and run `sgtest.m`. This works in Windows and Linux and you can run it directly opening Matlab. For various configuration options open the file for editing, options are located at the very top of the script.

 - To run the program without opening Matlab run `slsf.py`. You should have Python version >= 3.0 and currently this is only tested in Ubuntu Linux. Various configuration options can be found at the top of the script. Running this script is desired since Matlab can crash when running `sgtest.m` inside Matlab. Running this python script will automatically open Matlab and start the script if a crash had occurred.


# Incorporating csmith

## Introduction

 - TODO

## Current Work

 - In a loop, we generate random C code (`randgen.c`) using csmith, then use a hard-
coded S-function (available in `ee_post.c`) to call the `main()` function generated by csmith.

 - We build the code using `mex` command and run a Simulink model `staticmodel.slx` which uses the S-function.

 - We build using various gcc optimization flags (e.g. O0, O1, O2) and
compare checksum generated by each of these builds. If a difference is found among the generated checksums, we get an error, which is stored in `errors` directory.

 - We are using a single integer input and output variable for our s-function 
(The s-function is located at `ee_post.c`) and these variables are
added into checksum generation process.

 - Only tested in Ubuntu/Linux so far.

### Details of current implementation

In current setup, I have two hand-coded files:

 - `ee_pre.c`: Two SL input and output variables declared on top of any code, so that both csmith generated code and s-function's code can access them. Content of this file is copied and pasted on top of csmith generated `randgen.c` file.

 - `ee_post.c`: The s-function code.

And then I generate `randgen.c` by calling `csmith`. We have the `main()` function in this `randgen.c`, which calculates checksum. This `main()` function is called by the s-function.

Finally, I concat (put content of each file, one after another) all of them like this:

randgen.c + ee_post.c = staticsfun.c 

## Issues/TODO

 - Try out different *compilers* (not just different optimization flags) 
and optimization flags to eventually check "Wrong Code" (as mentioned by 
csmith work - when run time output of same source 
file is different changing compilers and optimization levels due to 
compiler bug).
 - Figure out how to calculate "checksum" (this is how csmith checks "wrong
code") for our case. This will incorporate both Simulink/Matlab variables and 
C-variables in the checksum generation procedure.
 - Refactor to run the loop outside Matlab [later if required].

## How to run

 - Call `run.py` from your shell.
 - We can tune some options (number of loops to run, whether to call csmith etc) by changing the options located at the top of `testrun.m` file.

## Set-up

 - Python3 (for running the scripts I've written)
 - csmith (see below for instructions)
 - Matlab with Simulink 

### Building and installing csmith

 - First clone source from https://github.com/shafiul/csmith
 - To build csmith, follow official doc at https://embed.cs.utah.edu/csmith/
 - You need `m4` library in Ubuntu
 - Once built, the csmith binary is located inside `src` directory.
 - We have to ensure csmith executable and `include` directory is in OS path (see below). 

### Set up environment variables

In linux, we can set up this way. Please note that we need both `csmith` and `matlab` executables in our path.

    export CSMITH_PATH=/path/to/csmith
    export PATH=$PATH:/$CSMITH_PATH/src:path/to/matlab/binary
    export C_INCLUDE_PATH=$CSMITH_PATH/runtime
    export CSMITH_HOME=$CSMITH_PATH # Needed for running csmith test driver

## Fixed Issues

 - Unsafe math operation at runtime: For some reason, I can not build the 
file `runtime/safe_math.h` with `mex` command. I've put a log in the logs 
folder. To get around this, I commented out line 100 of 
`csmith/runtime/random_inc.h`. So, run-time unsafe math operation (i.e. 
division by 0) leads to crash. Also "tuned" csmith to NOT include the safe
math operation wrappers (passing --no-safe-math argument). (FIXED)

- Handle aparantly non-terminating code (csmith uses timeout in their 
test suit). This is fixed, but killed processes are somehow leaking and 
processor usage is very high. Need to fix this. (FIXED)

